<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down GP Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        window.firebaseInit = async function() { console.log("System ready"); };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; color: #1f2937; user-select: none; }
        canvas { background-color: #4ade80; border-radius: 8px; cursor: default; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden p-4">
    
    <!-- Top Bar -->
    <div class="flex-shrink-0 flex justify-between items-center mb-4 bg-white p-3 rounded-lg shadow-sm border border-gray-200">
        <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
            üèçÔ∏è <span>GP Vector Manager</span>
        </h1>
        <div class="flex items-center gap-3">
            <select id="trackSelect" onchange="changeMode(this.value)" class="bg-gray-50 border border-gray-300 text-gray-700 py-1.5 px-3 rounded text-sm font-medium focus:ring-2 focus:ring-blue-500 outline-none">
                <option value="s-curve">Circuito S (T√©cnico)</option>
                <option value="stadium">Estadio Oval</option>
                <option value="l-shape">Circuito L</option>
                <option value="test-all" class="bg-gray-200 font-bold">üî¨ LAB: TODAS</option>
            </select>
            
            <button onclick="togglePause()" id="pauseBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1.5 px-4 rounded shadow-sm text-sm w-24 text-center">
                ‚è∏Ô∏è Pausa
            </button>

            <div class="flex items-center gap-2 px-3 py-1.5 bg-red-50 border border-red-200 rounded hover:bg-red-100 transition-colors">
                <input type="checkbox" id="debugMode" class="w-4 h-4 text-red-600 rounded focus:ring-red-500 cursor-pointer">
                <label for="debugMode" class="text-sm text-red-700 font-bold cursor-pointer select-none">Editar Trazada</label>
            </div>

            <button onclick="restartAll()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1.5 px-4 rounded shadow-sm text-sm transition-transform active:scale-95 flex items-center gap-2">
                <span>üîÑ</span> Reiniciar
            </button>
        </div>
    </div>

    <div id="loadingMessage" class="text-center text-lg text-blue-600">Preparando Pista...</div>

    <!-- Main Grid -->
    <div id="gameContainer" class="hidden flex-grow flex gap-4 overflow-hidden">
        
        <!-- Left Column -->
        <div class="flex-grow flex flex-col gap-4 overflow-y-auto" style="min-width: 0;">
            <div id="canvasGrid" class="grid grid-cols-1 gap-4"></div>

            <!-- Strategy Panel -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-gray-200 flex-shrink-0">
                <div class="flex justify-between items-center border-b pb-2 mb-3">
                    <h3 class="font-bold text-gray-800">üéÆ Estrategia de Equipo</h3>
                    <span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">Clic en piloto para c√°mara</span>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="playerControls"></div>
            </div>
        </div>

        <!-- Right Column -->
        <div class="w-72 flex-shrink-0 flex flex-col bg-white rounded-xl shadow-sm border border-gray-200 h-full overflow-hidden">
            <div class="p-3 border-b border-gray-100 bg-gray-50">
                <h2 class="font-bold text-gray-700 flex justify-between items-center">
                    Posiciones
                    <span class="text-xs font-normal bg-white px-2 py-0.5 rounded border text-gray-500">
                        Vueltas: <span id="lapCount" class="font-bold text-gray-800">0</span>/<span id="totalLapsDisplay">0</span>
                    </span>
                </h2>
            </div>
            <div class="flex-grow overflow-y-auto p-2">
                <ul id="scoreboard" class="space-y-1"></ul>
            </div>
            <div class="p-3 border-t border-gray-100 bg-gray-50">
                <div id="raceStatus" class="w-full py-2 rounded text-center text-sm font-bold bg-gray-200 text-gray-600">
                    Cargando...
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Config ---
        const RACER_NAMES_SOURCE = ["Joan", "Juan", "Brayan", "Fico", "Juani", "Edu", "Mechi", "Coco", "Gonza", "Dani", "Martin"];
        const RACER_COLORS_SOURCE = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899', '#f43f5e', '#64748b', '#14b8a6'];
        const RACER_NUMBERS_SOURCE = [1, 5, 7, 14, 18, 21, 25, 27, 31, 33, 37];
        const PLAYER_INDICES = [0, 1];
        
        const TARGET_RACE_PIXELS = 9000; 
        const RACER_RADIUS = 7; 
        const VELOCITY = 1.8; 
        const START_DELAY_FRAMES = 60; 

        // State
        let sessions = []; 
        let animationFrameId;
        let isPaused = false;
        let globalSelectedRacerId = 0; 
        let globalParams = {
            0: { tireAggression: 60, engineMap: 60, risk: 60 },
            1: { tireAggression: 60, engineMap: 60, risk: 60 }
        };

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- GEOMETRY (Visual Track) ---
        const STEP_SIZE = 2;
        function addLine(path, x1, y1, x2, y2) {
            const dist = Math.hypot(x2 - x1, y2 - y1);
            const steps = Math.ceil(dist / STEP_SIZE);
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                path.push({ x: x1 + (x2 - x1) * t, y: y1 + (y2 - y1) * t });
            }
        }
        function addArc(path, cx, cy, r, startAngle, endAngle) {
            let sweep = endAngle - startAngle;
            const len = Math.abs(sweep) * r;
            const steps = Math.ceil(len / STEP_SIZE);
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const a = startAngle + sweep * t;
                path.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
            }
        }

        // --- BEZIER SPLINE (Physics Path) ---
        function getBezierPoint(p0, cp1, cp2, p3, t) {
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            const t2 = t * t;
            const t3 = t2 * t;
            const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p3.x;
            const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p3.y;
            return { x, y };
        }

        function generateRacingLineFromNodes(nodes) {
            let path = [];
            const pointsPerSegment = 60; 
            for (let i = 0; i < nodes.length; i++) {
                const curr = nodes[i];
                const next = nodes[(i + 1) % nodes.length];
                const p0 = { x: curr.x, y: curr.y };
                const cp1 = { x: curr.x + curr.handleOut.x, y: curr.y + curr.handleOut.y };
                const cp2 = { x: next.x + next.handleIn.x, y: next.y + next.handleIn.y };
                const p3 = { x: next.x, y: next.y };
                for (let j = 0; j < pointsPerSegment; j++) {
                    const t = j / pointsPerSegment;
                    path.push(getBezierPoint(p0, cp1, cp2, p3, t));
                }
            }
            return path;
        }

        // --- 1. STATIC VISUAL TRACK DEFINITIONS ---
        function getVisualTrackPoints(type) {
            let p = [];
            if (type === 'l-shape') {
                const R = 60, ox = 200, oy = 100;
                const startX = 400; const topY = 50 + oy; const rightX = 650; const midY = 200 + oy; const midX = 250 + ox; const botY = 350 + oy; const leftX = 50 + ox;
                addLine(p, startX, topY, rightX - R, topY);
                addArc(p, rightX - R, topY + R, -Math.PI/2, 0);
                addLine(p, rightX, topY + R, rightX, midY - R);
                addArc(p, rightX - R, midY - R, 0, Math.PI/2);
                addLine(p, rightX - R, midY, midX + R, midY);
                addArc(p, midX + R, midY + R, -Math.PI/2, -Math.PI);
                addLine(p, midX, midY + R, midX, botY - R);
                addArc(p, midX - R, botY - R, 0, Math.PI/2); 
                addLine(p, midX - R, botY, leftX + R, botY);
                addArc(p, leftX + R, botY - R, Math.PI/2, Math.PI);
                addLine(p, leftX, botY - R, leftX, topY + R);
                addArc(p, leftX + R, topY + R, Math.PI, 3*Math.PI/2);
                addLine(p, leftX + R, topY, startX, topY);
            } else if (type === 's-curve') {
                const R = 80, ox = 200, oy = 200, startOffset = 200; 
                addLine(p, ox+300 + startOffset, oy, ox+750, oy);
                addArc(p, ox+750, oy+R, R, -Math.PI/2, Math.PI/2);
                addLine(p, ox+750, oy+2*R, ox+500, oy+2*R);
                addArc(p, ox+500, oy+3*R, R, -Math.PI/2, -Math.PI);
                addLine(p, ox+500-R, oy+3*R, ox+500-R, oy+3.5*R);
                addArc(p, ox+500-2*R, oy+3.5*R, R, 0, Math.PI/2);
                addLine(p, ox+500-2*R, oy+4.5*R, ox+R, oy+4.5*R);
                addArc(p, ox+R, oy+3.5*R, R, Math.PI/2, -Math.PI/2);
                addLine(p, ox, oy+3.5*R, ox, oy+R);
                addArc(p, ox+R, oy+R, R, Math.PI, 3*Math.PI/2); 
                addLine(p, ox+R, oy, ox+300 + startOffset, oy);
            } else {
                const cx = 500, cy = 400, w = 600, h = 300, r = h/2;
                const lx = cx - w/4, rx = cx + w/4, ty = cy - r, by = cy + r, startOffset = 150;
                addLine(p, lx + startOffset, ty, rx, ty);
                addArc(p, rx, cy, r, -Math.PI/2, Math.PI/2);
                addLine(p, rx, by, lx, by);
                addArc(p, lx, cy, r, Math.PI/2, 3*Math.PI/2);
                addLine(p, lx, ty, lx + startOffset, ty);
            }
            return p;
        }

        // --- 2. DYNAMIC RACING LINE NODES (Editable) ---
        function getBezierNodes(type) {
            if (type === 'l-shape') {
                return [
                    {x: 400, y: 150, handleIn: {x:-50, y:0}, handleOut: {x:50, y:0}}, 
                    {x: 600, y: 150, handleIn: {x:-50, y:0}, handleOut: {x:30, y:0}},
                    {x: 650, y: 200, handleIn: {x:0, y:-30}, handleOut: {x:0, y:30}},
                    {x: 650, y: 250, handleIn: {x:0, y:-30}, handleOut: {x:0, y:30}},
                    {x: 600, y: 300, handleIn: {x:30, y:0}, handleOut: {x:-30, y:0}},
                    {x: 500, y: 300, handleIn: {x:30, y:0}, handleOut: {x:-30, y:0}},
                    {x: 450, y: 350, handleIn: {x:0, y:-30}, handleOut: {x:0, y:30}},
                    {x: 450, y: 400, handleIn: {x:0, y:-30}, handleOut: {x:0, y:30}},
                    {x: 400, y: 450, handleIn: {x:30, y:0}, handleOut: {x:-30, y:0}},
                    {x: 300, y: 450, handleIn: {x:30, y:0}, handleOut: {x:-30, y:0}},
                    {x: 250, y: 400, handleIn: {x:0, y:30}, handleOut: {x:0, y:-30}},
                    {x: 250, y: 200, handleIn: {x:0, y:30}, handleOut: {x:0, y:-30}},
                    {x: 300, y: 150, handleIn: {x:-30, y:0}, handleOut: {x:30, y:0}}
                ];
            } else if (type === 's-curve') {
                return [
                    {x: 600, y: 200, handleIn: {x:-50, y:0}, handleOut: {x:50, y:0}}, // Top Straight Mid
                    {x: 900, y: 200, handleIn: {x:-50, y:0}, handleOut: {x:30, y:0}}, // Approach T1
                    {x: 1030, y: 280, handleIn: {x:0, y:-40}, handleOut: {x:0, y:40}}, // T1 Apex
                    {x: 950, y: 360, handleIn: {x:30, y:0}, handleOut: {x:-50, y:0}}, // T1 Exit
                    {x: 700, y: 360, handleIn: {x:50, y:0}, handleOut: {x:-30, y:0}}, // Back Straight
                    {x: 620, y: 440, handleIn: {x:0, y:-40}, handleOut: {x:0, y:40}}, // S-Entry Apex
                    {x: 580, y: 500, handleIn: {x:20, y:-20}, handleOut: {x:-20, y:20}}, // S-Link
                    {x: 500, y: 560, handleIn: {x:30, y:0}, handleOut: {x:-30, y:0}}, // S-Exit
                    {x: 360, y: 480, handleIn: {x:0, y:40}, handleOut: {x:0, y:-40}}, // Hairpin Apex
                    {x: 360, y: 360, handleIn: {x:0, y:40}, handleOut: {x:0, y:-40}}, // Up Straight
                    {x: 380, y: 280, handleIn: {x:-20, y:20}, handleOut: {x:20, y:-20}}, // Final Corner Entry
                    {x: 440, y: 200, handleIn: {x:-20, y:10}, handleOut: {x:30, y:0}}  // Join Top
                ];
            } else {
                // Stadium
                return [
                    {x: 500, y: 250, handleIn: {x:-50, y:0}, handleOut: {x:50, y:0}}, 
                    {x: 650, y: 250, handleIn: {x:-50, y:0}, handleOut: {x:50, y:0}}, 
                    {x: 800, y: 400, handleIn: {x:0, y:-50}, handleOut: {x:0, y:50}}, 
                    {x: 650, y: 550, handleIn: {x:50, y:0}, handleOut: {x:-50, y:0}}, 
                    {x: 350, y: 550, handleIn: {x:50, y:0}, handleOut: {x:-50, y:0}}, 
                    {x: 200, y: 400, handleIn: {x:0, y:50}, handleOut: {x:0, y:-50}}, 
                    {x: 350, y: 250, handleIn: {x:-50, y:0}, handleOut: {x:50, y:0}}  
                ];
            }
        }

        class RaceSession {
            constructor(containerId, trackType, title) {
                this.trackType = trackType;
                this.title = title;
                this.visualPath = getVisualTrackPoints(trackType);
                this.bezierNodes = getBezierNodes(trackType);
                this.racingPath = [];
                this.racers = [];
                this.totalLaps = 5;
                this.raceFrameCount = 0;
                this.camera = { x: 0, y: 0 };
                this.raceFinished = false;
                this.dragTarget = null; 
                
                this.container = document.createElement('div');
                this.container.className = "flex flex-col gap-2 w-full";
                
                if (title !== 'Main Race') {
                    const header = document.createElement('div');
                    header.className = "font-bold text-gray-600 text-xs uppercase flex justify-between";
                    header.innerHTML = `<span>${title}</span> <span id="status-${title}" class="bg-gray-200 px-2 rounded">...</span>`;
                    this.container.appendChild(header);
                }
                const canvasWrap = document.createElement('div');
                canvasWrap.className = "relative w-full bg-gray-800 rounded-lg border-4 border-gray-700 overflow-hidden shadow-inner";
                this.canvas = document.createElement('canvas');
                this.canvas.width = 700;
                this.canvas.height = 400;
                this.canvas.className = "block bg-gray-900 w-full h-auto rounded";
                this.ctx = this.canvas.getContext('2d');
                
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.onMouseUp());

                canvasWrap.appendChild(this.canvas);
                this.container.appendChild(canvasWrap);
                document.getElementById(containerId).appendChild(this.container);
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const sx = this.canvas.width / rect.width;
                const sy = this.canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * sx + this.camera.x,
                    y: (e.clientY - rect.top) * sy + this.camera.y
                };
            }

            onMouseDown(e) {
                if (!document.getElementById('debugMode').checked) return;
                const m = this.getMousePos(e);
                for (let i = 0; i < this.bezierNodes.length; i++) {
                    const n = this.bezierNodes[i];
                    if (Math.hypot((n.x+n.handleIn.x)-m.x, (n.y+n.handleIn.y)-m.y) < 15) { this.dragTarget = { type: 'in', index: i }; return; }
                    if (Math.hypot((n.x+n.handleOut.x)-m.x, (n.y+n.handleOut.y)-m.y) < 15) { this.dragTarget = { type: 'out', index: i }; return; }
                    if (Math.hypot(n.x - m.x, n.y - m.y) < 15) { this.dragTarget = { type: 'anchor', index: i }; return; }
                }
            }

            onMouseMove(e) {
                const debug = document.getElementById('debugMode').checked;
                if (debug && !this.dragTarget) {
                    this.canvas.style.cursor = 'pointer'; 
                } else if (this.dragTarget) {
                    this.canvas.style.cursor = 'grabbing';
                    const m = this.getMousePos(e);
                    const node = this.bezierNodes[this.dragTarget.index];
                    if (this.dragTarget.type === 'anchor') { node.x = m.x; node.y = m.y; }
                    else if (this.dragTarget.type === 'in') { node.handleIn.x = m.x - node.x; node.handleIn.y = m.y - node.y; }
                    else if (this.dragTarget.type === 'out') { node.handleOut.x = m.x - node.x; node.handleOut.y = m.y - node.y; }
                    this.racingPath = generateRacingLineFromNodes(this.bezierNodes);
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }

            onMouseUp() { this.dragTarget = null; }

            init() {
                this.racingPath = generateRacingLineFromNodes(this.bezierNodes);
                const trackLen = this.racingPath.length * 2; 
                this.totalLaps = Math.max(3, Math.round(TARGET_RACE_PIXELS / trackLen));
                if (this.title === 'Main Race' || this.title === 'Stadium') {
                    const el = document.getElementById('totalLapsDisplay');
                    if(el) el.textContent = this.totalLaps;
                }

                this.racers = [];
                this.raceFrameCount = 0;
                this.raceFinished = false;
                this.camera = { x: 0, y: 0 };

                // Use racing path for grid logic
                const startPoint = this.racingPath[0];
                const pTrack = this.racingPath[10];
                const dx = pTrack.x - startPoint.x;
                const dy = pTrack.y - startPoint.y;
                const angle = Math.atan2(dy, dx);
                
                const len = Math.hypot(dx, dy);
                const dirX = dx/len; const dirY = dy/len;
                const perpX = -dirY; const perpY = dirX;

                const names = shuffleArray([...RACER_NAMES_SOURCE]);
                const colors = shuffleArray([...RACER_COLORS_SOURCE]);
                const numbers = shuffleArray([...RACER_NUMBERS_SOURCE]);

                for (let i = 0; i < names.length; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    let colOffset = col - 1; 
                    if (row === 3) colOffset = col - 0.5;

                    const distBack = 60 + (row * 35);
                    const distSide = colOffset * 25;

                    const posX = startPoint.x - (dirX * distBack) + (perpX * distSide);
                    const posY = startPoint.y - (dirY * distBack) + (perpY * distSide);
                    const isPlayer = PLAYER_INDICES.includes(i);
                    const lanePref = (Math.random() * 40) - 20;

                    this.racers.push({
                        id: i,
                        name: names[i], color: colors[i], racingNumber: numbers[i],
                        x: posX, y: posY, fuel: 100, tires: 100,
                        params: isPlayer ? {...globalParams[i]} : { 
                            tireAggression: 40 + Math.random()*40, engineMap: 40+Math.random()*40, risk: 30+Math.random()*40 
                        },
                        isPlayer, state: 'waiting', launchDelay: Math.floor(Math.random()*15), launchAccel: 0.05+Math.random()*0.02, currentSpeed: 0,
                        pathIndex: 0, lap: 0, progress: 0, finished: false, finishTime: 0,
                        angle: angle, laneOffset: lanePref, wobblePhase: Math.random()*Math.PI*2
                    });
                }
                this.updateCamera();
                this.draw();
            }

            update() {
                if (isPaused) {
                    this.updateCamera();
                    this.draw();
                    return;
                }

                this.raceFrameCount++;
                this.racers.forEach(r => this.updateRacerLogic(r));
                this.resolveCollisions();
                this.updateCamera();
                this.checkFinishState();
            }

            checkFinishState() {
                const finishedCount = this.racers.filter(r => r.finished).length;
                let statusText = "Carrera en Curso";
                let statusClass = "mt-4 p-2 bg-gray-100 rounded text-center text-sm font-bold text-gray-600";

                if (!this.raceFinished && finishedCount === this.racers.length) {
                    this.raceFinished = true;
                    statusText = "üèÅ FINALIZADO";
                    statusClass = "mt-4 p-2 bg-green-200 text-green-800 border border-green-300 rounded text-center text-sm font-bold";
                } else if (this.raceFrameCount < START_DELAY_FRAMES) {
                    statusText = "üî¥ PREPARADOS...";
                    statusClass = "mt-4 p-2 bg-red-100 text-red-800 border border-red-200 rounded text-center text-sm font-bold";
                } else if (this.raceFrameCount < START_DELAY_FRAMES + 30) {
                    statusText = "üü¢ ¬°LARGARON!";
                    statusClass = "mt-4 p-2 bg-green-500 text-white border border-green-600 rounded text-center text-sm font-bold shadow-lg transform scale-105";
                }

                const el = document.getElementById('raceStatus');
                if (el && el.textContent !== statusText) {
                    el.textContent = statusText;
                    el.className = statusClass;
                }
            }

            updateRacerLogic(racer) {
                if (this.raceFrameCount < START_DELAY_FRAMES) { racer.currentSpeed = 0; return; }
                if (this.raceFrameCount < START_DELAY_FRAMES + racer.launchDelay) return;

                const pixelsMoved = racer.currentSpeed;
                
                if (!racer.finished) {
                    const fDrain = 0.008 + 0.005 * (racer.params.engineMap / 100);
                    racer.fuel = Math.max(0, racer.fuel - racer.currentSpeed * fDrain);
                    const tWear = 0.006 + 0.006 * (racer.params.tireAggression / 100);
                    racer.tires = Math.max(0, racer.tires - racer.currentSpeed * tWear);
                }

                let speedMult = 1.0;
                if (racer.finished) {
                    speedMult = 0.5; 
                } else {
                    if (racer.fuel > 0) speedMult *= 0.82 + 0.3 * (racer.params.engineMap / 100); else speedMult *= 0.4; 
                    if (racer.tires < 20) speedMult *= 0.6 + 0.4 * (racer.tires / 20);
                    speedMult *= (1 + (Math.random() * 0.04 - 0.02));
                }
                
                const maxSpeed = VELOCITY * speedMult;
                if (racer.currentSpeed < maxSpeed) {
                    if (racer.currentSpeed < 0.5 && !racer.finished) racer.currentSpeed += racer.launchAccel;
                    else racer.currentSpeed += 0.02; 
                } else {
                    racer.currentSpeed -= 0.002; 
                    if (racer.currentSpeed < maxSpeed) racer.currentSpeed = maxSpeed;
                }

                const path = this.racingPath; 
                const lookAhead = 35;
                const targetIdx = (racer.pathIndex + lookAhead) % path.length;
                const centerPt = path[targetIdx];

                const nextPt = path[(targetIdx + 5) % path.length];
                const prevPt = path[(targetIdx - 5 + path.length) % path.length];
                let tx = nextPt.x - prevPt.x; let ty = nextPt.y - prevPt.y;
                const tLen = Math.hypot(tx, ty);
                if (tLen > 0) { tx /= tLen; ty /= tLen; }
                const px = -ty; const py = tx;

                const wobble = Math.sin(this.raceFrameCount * 0.05 + racer.wobblePhase) * 5;
                const off = racer.laneOffset + wobble;
                const txPos = centerPt.x + px * off;
                const tyPos = centerPt.y + py * off;

                const dx = txPos - racer.x; const dy = tyPos - racer.y;
                const targetAngle = Math.atan2(dy, dx);
                
                let angDiff = targetAngle - racer.angle;
                while (angDiff <= -Math.PI) angDiff += Math.PI * 2;
                while (angDiff > Math.PI) angDiff -= Math.PI * 2;

                if (Math.abs(angDiff) > Math.PI / 1.9) {
                     const safe = path[(targetIdx+20)%path.length];
                     const safeA = Math.atan2(safe.y-racer.y, safe.x-racer.x);
                     angDiff = safeA - racer.angle;
                     while (angDiff <= -Math.PI) angDiff += Math.PI * 2;
                     while (angDiff > Math.PI) angDiff -= Math.PI * 2;
                }

                if (Math.abs(angDiff) > Math.PI/2) angDiff *= 0.1;
                const steer = Math.max(Math.min(angDiff, 0.12), -0.12);
                
                racer.angle += steer + (Math.random() - 0.5) * 0.02;
                racer.x += Math.cos(racer.angle) * racer.currentSpeed;
                racer.y += Math.sin(racer.angle) * racer.currentSpeed;

                const skip = 100;
                for(let i=1; i<=skip; i++) {
                    const cIdx = (racer.pathIndex + i) % path.length;
                    const pt = path[cIdx];
                    const dist = Math.hypot(pt.x - racer.x, pt.y - racer.y);
                    if (dist < 60) {
                        if (racer.pathIndex > path.length*0.9 && cIdx < path.length*0.1) {
                            if (dist > 30) continue; 
                            if (!racer.finished) {
                                racer.lap++;
                                if (racer.lap >= this.totalLaps) {
                                    racer.finished = true;
                                    racer.finishTime = performance.now();
                                    racer.progress = this.totalLaps + 1000;
                                }
                            }
                        }
                        racer.pathIndex = cIdx;
                        break;
                    }
                }
                if (!racer.finished) racer.progress = racer.lap + (racer.pathIndex / path.length);
            }

            resolveCollisions() {
                for (let i = 0; i < this.racers.length; i++) {
                    for (let j = i + 1; j < this.racers.length; j++) {
                        const r1 = this.racers[i]; const r2 = this.racers[j];
                        const dx = r2.x - r1.x; const dy = r2.y - r1.y;
                        const dist = Math.hypot(dx, dy);
                        const buffer = 8 * (1 - (r1.params.risk + r2.params.risk)/200);
                        const minDist = (RACER_RADIUS * 2) + buffer;
                        if (dist < minDist) {
                            const safe = dist || 0.01; 
                            const overlap = minDist - safe;
                            const nx = dx/safe; const ny = dy/safe;
                            const f = 0.2;
                            r1.x -= nx * overlap * f; r1.y -= ny * overlap * f;
                            r2.x += nx * overlap * f; r2.y += ny * overlap * f;
                        }
                    }
                }
            }

            updateCamera() {
                const target = this.racers.find(r => r.id === globalSelectedRacerId) || this.racers[0];
                const tx = target.x - 700/2; const ty = target.y - 400/2;
                this.camera.x += (tx - this.camera.x) * 0.1;
                this.camera.y += (ty - this.camera.y) * 0.1;
            }

            draw() {
                this.ctx.clearRect(0, 0, 700, 400);
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // 1. Draw VISUAL Track (Static Geometry)
                const trackWidth = 140;
                this.ctx.lineJoin = 'round'; this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                if (this.visualPath.length > 0) this.ctx.moveTo(this.visualPath[0].x, this.visualPath[0].y);
                for(let i=1; i<this.visualPath.length; i+=4) this.ctx.lineTo(this.visualPath[i].x, this.visualPath[i].y);
                this.ctx.closePath();
                this.ctx.lineWidth = trackWidth; this.ctx.strokeStyle = '#374151'; this.ctx.stroke();
                
                this.ctx.lineWidth = 4; this.ctx.strokeStyle = '#f8fafc';
                for (let i = 0; i < this.visualPath.length; i += 10) {
                    const p1 = this.visualPath[i]; const p2 = this.visualPath[(i+5)%this.visualPath.length];
                    const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const perp = ang + Math.PI/2;
                    const dx = (trackWidth/2)*Math.cos(perp); const dy = (trackWidth/2)*Math.sin(perp);
                    this.ctx.beginPath(); this.ctx.moveTo(p1.x+dx, p1.y+dy); this.ctx.lineTo(p2.x+dx, p2.y+dy); this.ctx.stroke();
                    this.ctx.beginPath(); this.ctx.moveTo(p1.x-dx, p1.y-dy); this.ctx.lineTo(p2.x-dx, p2.y-dy); this.ctx.stroke();
                }

                // 2. Finish Line (Visual)
                if (this.visualPath.length > 20) {
                    const p1 = this.visualPath[0]; const p2 = this.visualPath[10];
                    const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    this.ctx.save(); this.ctx.translate(p1.x, p1.y); this.ctx.rotate(ang + Math.PI/2);
                    const w = trackWidth; this.ctx.fillStyle='#fff'; this.ctx.fillRect(-w/2,-4,w,8);
                    this.ctx.fillStyle='#000'; 
                    for(let k=0;k<10;k++) {
                        if(k%2===0) this.ctx.fillRect(-w/2+(k*(w/10)),-4,w/10,4);
                        else this.ctx.fillRect(-w/2+(k*(w/10)),0,w/10,4);
                    }
                    this.ctx.restore();
                }

                // 3. DEBUG: Draw Splines & Controls
                if (document.getElementById('debugMode').checked) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    if(this.racingPath.length>0) this.ctx.moveTo(this.racingPath[0].x, this.racingPath[0].y);
                    for(let pt of this.racingPath) this.ctx.lineTo(pt.x, pt.y);
                    this.ctx.stroke();

                    this.bezierNodes.forEach((n, i) => {
                        this.ctx.beginPath();
                        this.ctx.moveTo(n.x + n.handleIn.x, n.y + n.handleIn.y);
                        this.ctx.lineTo(n.x, n.y);
                        this.ctx.lineTo(n.x + n.handleOut.x, n.y + n.handleOut.y);
                        this.ctx.strokeStyle = '#999'; this.ctx.lineWidth = 1; this.ctx.stroke();

                        this.ctx.fillStyle = '#ef4444';
                        this.ctx.beginPath(); this.ctx.arc(n.x+n.handleIn.x, n.y+n.handleIn.y, 4, 0, Math.PI*2); this.ctx.fill();
                        this.ctx.beginPath(); this.ctx.arc(n.x+n.handleOut.x, n.y+n.handleOut.y, 4, 0, Math.PI*2); this.ctx.fill();

                        this.ctx.fillStyle = '#3b82f6';
                        this.ctx.fillRect(n.x-5, n.y-5, 10, 10);
                    });
                }

                this.racers.forEach(r => this.drawRacer(r));
                this.ctx.restore();
            }

            drawRacer(racer) {
                if (racer.x < this.camera.x - 50 || racer.x > this.camera.x + 750 ||
                    racer.y < this.camera.y - 50 || racer.y > this.camera.y + 450) return;

                this.ctx.save();
                this.ctx.translate(racer.x, racer.y);
                
                if (racer.id === globalSelectedRacerId) {
                    this.ctx.beginPath(); this.ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)'; this.ctx.lineWidth = 3; this.ctx.stroke();
                } else if (racer.isPlayer) {
                    this.ctx.beginPath(); this.ctx.arc(0, 0, 16, 0, Math.PI * 2);
                    this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; this.ctx.lineWidth = 2; this.ctx.stroke();
                }

                this.ctx.rotate(racer.angle);
                const scale = 0.7; 
                this.ctx.shadowColor = 'rgba(0,0,0,0.4)'; this.ctx.shadowBlur = 4; this.ctx.shadowOffsetX = 2; this.ctx.shadowOffsetY = 2;
                this.ctx.fillStyle = '#1f2937'; 
                this.ctx.beginPath(); this.ctx.roundRect(-16*scale, -5*scale, 8*scale, 10*scale, 2*scale); this.ctx.fill();
                this.ctx.beginPath(); this.ctx.roundRect(12*scale, -4*scale, 6*scale, 8*scale, 2*scale); this.ctx.fill();
                this.ctx.fillStyle = '#9ca3af'; this.ctx.fillRect(-8 * scale, -2 * scale, 20 * scale, 4 * scale);
                this.ctx.fillStyle = racer.color;
                this.ctx.beginPath(); this.ctx.moveTo(-8 * scale, -6 * scale); this.ctx.lineTo(6 * scale, -5 * scale); this.ctx.lineTo(10 * scale, -2 * scale); 
                this.ctx.lineTo(10 * scale, 2 * scale); this.ctx.lineTo(6 * scale, 5 * scale); this.ctx.lineTo(-8 * scale, 6 * scale);
                this.ctx.closePath(); this.ctx.fill();
                this.ctx.fillStyle = racer.color; this.ctx.beginPath(); this.ctx.ellipse(-2 * scale, 0, 5 * scale, 7 * scale, 0, 0, Math.PI * 2); this.ctx.fill();
                this.ctx.fillStyle = '#ffffff'; this.ctx.beginPath(); this.ctx.arc(0, 0, 3.5 * scale, 0, Math.PI * 2); this.ctx.fill();
                this.ctx.fillStyle = '#000000'; this.ctx.beginPath(); this.ctx.arc(0, 0, 3.5 * scale, -Math.PI/5, Math.PI/5); this.ctx.lineTo(2 * scale, 0); this.ctx.fill();
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.translate(racer.x, racer.y); 
                this.ctx.fillStyle = '#000'; this.ctx.font = 'bold 10px Inter'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'bottom';
                this.ctx.fillText(`#${racer.racingNumber}`, 0, -12);
                if (racer.fuel <= 0) this.ctx.fillText("‚ö†Ô∏è", 0, -25);
                this.ctx.restore();
            }
        }

        // --- Manager Logic ---
        function updateGlobalScoreboard() {
            if (sessions.length === 0) return;
            const s = sessions[0];
            const sorted = [...s.racers].sort((a, b) => {
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                if (a.finished !== b.finished) return a.finished ? -1 : 1;
                return b.progress - a.progress;
            });

            const sb = document.getElementById('scoreboard');
            const lapCountEl = document.getElementById('lapCount');
            const totalLapsEl = document.getElementById('totalLapsDisplay');

            if(!sb) return;
            
            let html = '';
            sorted.forEach((r, idx) => {
                const highlight = r.id === globalSelectedRacerId ? 'bg-blue-50 border-blue-200' : 'border-gray-100';
                const playerIndicator = r.isPlayer ? `<span class="border-l-4" style="border-color:${r.color}"></span>` : '';
                
                let status = `${r.lap}/${s.totalLaps}`;
                if(r.finished) status = `<span class="text-green-600 font-bold">FIN</span>`;
                
                html += `
                <li class="flex justify-between items-center p-1.5 rounded bg-white border mb-1 text-xs gap-2 ${highlight}" onclick="selectPilot(${r.id})" style="cursor:pointer">
                    <div class="flex items-center min-w-0 flex-grow gap-2">
                        ${playerIndicator}
                        <span class="w-4 font-bold text-gray-400 text-center">${idx+1}</span>
                        <div class="w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${r.color}"></div>
                        <span class="w-6 font-mono text-gray-500 font-bold text-right text-[10px] bg-gray-50 px-1 rounded border border-gray-200">#${r.racingNumber}</span>
                        <span class="font-medium truncate text-gray-800 ${r.id===globalSelectedRacerId ? 'text-blue-600':''}">${r.name}</span>
                        ${r.isPlayer ? '<span class="px-1 py-0.5 bg-blue-100 text-blue-800 rounded text-[9px] font-bold">TU</span>' : ''}
                    </div>
                    <span class="font-mono text-gray-500">${status}</span>
                </li>`;
            });
            sb.innerHTML = html;

            if (lapCountEl && sorted.length > 0) {
                lapCountEl.textContent = sorted[0].lap;
            }
            if (totalLapsEl) {
                totalLapsEl.textContent = s.totalLaps;
            }
        }

        window.togglePause = function() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            if (btn) {
                btn.textContent = isPaused ? "‚ñ∂Ô∏è Seguir" : "‚è∏Ô∏è Pausa";
                btn.className = isPaused ? "bg-green-600 hover:bg-green-700 text-white font-bold py-1.5 px-4 rounded shadow-sm text-sm w-24 text-center" : "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1.5 px-4 rounded shadow-sm text-sm w-24 text-center";
            }
        }

        window.changeMode = function(mode) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            const grid = document.getElementById('canvasGrid');
            if(grid) grid.innerHTML = ''; 
            sessions = [];
            isPaused = false;
            const pBtn = document.getElementById('pauseBtn');
            if(pBtn) {
                pBtn.textContent = "‚è∏Ô∏è Pausa";
                pBtn.className = "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1.5 px-4 rounded shadow-sm text-sm w-24 text-center";
            }

            if (mode === 'test-all') {
                grid.className = "grid grid-cols-1 lg:grid-cols-3 gap-6";
                sessions.push(new RaceSession('canvasGrid', 'stadium', 'Stadium'));
                sessions.push(new RaceSession('canvasGrid', 'l-shape', 'L-Circuit'));
                sessions.push(new RaceSession('canvasGrid', 's-curve', 'S-Curve'));
            } else {
                grid.className = "grid grid-cols-1 gap-6";
                sessions.push(new RaceSession('canvasGrid', mode, 'Main Race'));
            }

            sessions.forEach(s => s.init());
            updateControlsUI();
            updateGlobalScoreboard();
            gameLoop();
        }

        window.restartAll = function() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            const mode = document.getElementById('trackSelect').value;
            changeMode(mode);
        }

        window.selectPilot = function(id) {
            globalSelectedRacerId = id;
            updateControlsUI();
            updateGlobalScoreboard();
        }

        window.updateParam = function(racerId, param, value) {
            if (!globalParams[racerId]) globalParams[racerId] = {};
            globalParams[racerId][param] = parseInt(value);
            sessions.forEach(s => {
                const r = s.racers.find(x => x.id === racerId);
                if (r) r.params[param] = parseInt(value);
            });
            updateControlsUI();
        }

        function updateControlsUI() {
            const container = document.getElementById('playerControls');
            if(!container) return;
            container.innerHTML = '';
            if (sessions.length === 0) return;
            const refRacers = sessions[0].racers;

            PLAYER_INDICES.forEach(index => {
                const racer = refRacers[index];
                if (!racer) return;
                const params = globalParams[racer.id];
                const isSelected = (racer.id === globalSelectedRacerId);
                const panel = document.createElement('div');
                panel.className = `border-l-4 p-3 bg-gray-50 rounded-r shadow-sm transition-all ${isSelected ? 'ring-2 ring-blue-400 bg-blue-50' : 'hover:bg-gray-100'}`;
                panel.style.borderColor = racer.color;

                const optionValues = [20, 40, 60, 80, 100];
                function createButtonRow(label, paramKey, currentVal) {
                    let btnsHtml = `<div class="flex gap-1">`;
                    optionValues.forEach((val, i) => {
                        const isActive = val === currentVal;
                        let colorClass = isActive 
                            ? (i>=3 ? "bg-red-500 text-white" : (i===2 ? "bg-blue-600 text-white" : "bg-green-600 text-white"))
                            : "bg-gray-200 text-gray-600 hover:bg-gray-300";
                        btnsHtml += `<button onclick="updateParam(${racer.id}, '${paramKey}', ${val})" class="flex-1 py-1 text-[10px] font-bold rounded ${colorClass}">${i + 1}</button>`;
                    });
                    return `<div><div class="flex justify-between text-[10px] text-gray-500 mb-0.5"><span class="uppercase font-semibold tracking-wide">${label}</span></div>${btnsHtml}</div></div>`;
                }

                panel.innerHTML = `
                    <div class="flex justify-between items-center mb-2 cursor-pointer select-none" onclick="selectPilot(${racer.id})">
                        <div class="font-bold text-gray-800 flex items-center text-sm">
                            <span class="w-2.5 h-2.5 rounded-full mr-2" style="background-color: ${racer.color}"></span>
                            ${racer.name} ${isSelected ? 'üëÅÔ∏è' : ''}
                        </div>
                        <div class="text-[10px] text-gray-400 font-mono">#${racer.racingNumber}</div>
                    </div>
                    <div class="space-y-2">
                        ${createButtonRow("Neum√°ticos", "tireAggression", params.tireAggression)}
                        ${createButtonRow("Motor", "engineMap", params.engineMap)}
                        ${createButtonRow("Riesgo", "risk", params.risk)}
                    </div>
                    <div class="mt-3 grid grid-cols-2 gap-2 text-[10px]">
                        <div class="bg-white p-1.5 rounded border">
                            <div class="text-gray-400">Neum√°ticos</div><div class="h-1 w-full bg-gray-100 mt-0.5 rounded"><div class="h-full bg-green-500 transition-all duration-500" style="width: ${racer.tires}%"></div></div>
                        </div>
                        <div class="bg-white p-1.5 rounded border">
                            <div class="text-gray-400">Combustible</div><div class="h-1 w-full bg-gray-100 mt-0.5 rounded"><div class="h-full bg-yellow-500 transition-all duration-500" style="width: ${racer.fuel}%"></div></div>
                        </div>
                    </div>
                `;
                container.appendChild(panel);
            });
        }

        function gameLoop() {
            sessions.forEach(s => {
                s.update();
                s.draw(); 
            });
            
            if (animationFrameId % 5 === 0) updateGlobalScoreboard(); 
            if (animationFrameId % 30 === 0) updateControlsUI(); 
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.onload = async function() {
            if (typeof window.firebaseInit === 'function') await window.firebaseInit();
            document.getElementById('loadingMessage').classList.add('hidden');
            document.getElementById('gameContainer').classList.remove('hidden');
            
            // Set default selection in dropdown to S-Curve
            document.getElementById('trackSelect').value = 's-curve';
            changeMode('s-curve');
        };
    </script>
</body>
</html>